\section{Uruchamianie i testowanie}
Rozdział ten zawiera generalne podsumowanie przebiegu prac nad projektem. Opisane zostaną tu~wszelkie poważne problemy, które wystąpiły w~czasie realizacji projektu. Ponadto zawarto~tu opis przebiegu procesu testowania.

\subsection{Przebieg testowania}
W procesie weryfikacji poprawności działania projektu zastosowano testowanie wstępujące. Na~początku powstał blok FB1 sterujący pojedynczym silnikiem, który następnie został wywołany dla wszystkich 4~silników z~odpowiednimi parametrami. W kolejnym etapie działające poprawnie sterowanie silnikami zostało wykorzystane do bardziej zaawansowanych funkcji i~tak aż do~osiągnięcia prawidłowych wyników testów wszystkich funkcji.

Głównym testerem był autor projektu więc większość testów przebiegała na zasadzie białej skrzynki (ang. \emph{white box}), bardzo często z~użyciem podglądu stanu w środowisku Step~7. Takie testowanie pozwala stosunkowo łatwo wyszukać źródło błędu i~je wyeliminować.

Autor kilka razy przeprowadzał testy stosując metodę czarnej skrzynki (ang. \emph{black box}), nie~biorąc pod uwagę zależności wykonywanych czynności, od~realizowanego przez sterownik kodu. Kilkukrotnie w czasie realizacji projektu do testów zgłaszały się osoby trzecie, które były nim zaciekawione. Testy wykonane przez takie osoby są niezwykle cenne ze względu na dużą nieprzewidywalność oraz całkowitą niezależność działań od rozwiązań ze~względu na~brak ich znajomości.

W kilku testach ze względu na destrukcyjny wpływ błędów na model robota, testy odbywały się bez podłączonych silników z~ręcznym wymuszaniem zmiany stanów krańcówek oraz impulsatorów. Takie działanie pozwoliło wykryć ewentualne błędy zanim kod je zawierający mógłby doprowadzić do uszkodzenia robota.
Taka metoda przypomina klasyczne testowanie zstępujące, gdzie elementy niżej położone w~hierarchii są~zastępowane przez zaślepki.

W~czasie realizacji autor stosował testowanie oparte na dwóch metodach analizy. Testowanie oprogramowania można wykonywać pod kątem analizy statycznej i~dynamicznej. Analiza statyczna polega na~sprawdzaniu kodu źródłowego i~znajdowaniu w~nim błędów bez uruchamiania sprawdzanego kodu. Ta~metoda była stosowana poza laboratorium, gdzie brak był dostępu do sterownika i~modelu. Podczas analizy dynamicznej oprogramowanie jest uruchamiane i~badane pod kątem ścieżki przebiegu i~czasu wykonywania. Ta metoda z~kolei była najważniejsza i~często wyniki tych testów były zaskakujące w~stosunku do~przeprowadzonych wcześniej z~zastosowaniem analizy statycznej.

Ostatnim etapem testów były~te przeprowadzone w~obecności promotora oraz te wykonane przez niego. Ostatecznie oprogramowanie zostało zatwierdzone i~uznane za spełniające wszystkie wstępne założenia przedstawione w~podrozdziale 1.2.
\newpage
\subsection{Napotkane problemy}
Podczas tworzenia projektu napotkane i~przeanalizowane zostały następujące problemy:
\begin{itemize}
\item Adresy w sterowniku a zmienne symboliczne:\\[1mm]
Po zdefiniowaniu zmiennej symbolicznej w tablicy Symbols zostaje ona użyta w~bloku stworzonym w~języku Ladderu. Następnie zostaje dokonana zmiana adresu tej zmiennej, co niestety powoduje, że we~wspomnianym wcześniej bloku zostaje pozostawiony pierwotny adres, zamiast zostać automatycznie zaktualizowany do nowej wartości. Niestety o~spójność adresów i nazw symbolicznych programista musi zadbać samodzielnie.

\item Brak przenośności adresów i nazw symbolicznych ze Step~7 do WinCC flexible:\\[1mm]
Niestety nie udało się odnaleźć opcji pobrania adresów ze~sterownika lub wyeksportowania w~środowisku Step~7 i zaimportowania w~WinCC~flexbile. Z~tego powodu dopisywanie lub edytowanie adresów zmiennych w~sterowniku wymagało pamiętania o~zrobieniu tego samego w~środowisku do tworzenia wizualizacji.

\item Bezwładność silników:\\[1mm]
Podczas pozycjonowania silnika do wybranej pozycji dochodziło do oscylacji w~okolicach wybranej wartości. Silnik po wyłączeniu, siłą bezwładności wykonał jeszcze ruch powodujący naliczenie jednego lub dwóch impulsów, więc oprogramowanie próbowało skorygować tę wartość do tej zadanej wcześniej. Czasami udało się uzyskać żądaną pozycję, a~czasami silnik pracował nieprzerwanie w~obie strony naprzemiennie.

\item Problem ze zliczaniem impulsów:\\[1mm]
Silnik inaczej nalicza impulsy podczas ruchu w kierunku wyłącznika krańcowego a inaczej w kierunku przeciwnym. Przykładowo ustawienie silnika Rotate na 100 i~powrót do~0 powodowało zatrzymanie silnika gdzieś w okolicach pozycji odpowiadającej wartości 15. Problem związany był z wykorzystaniem zmiennych tymczasowych do przechowywania zmiennych pomocniczych związanych z ustawianiem kierunku pracy silnika. Błędne użycie danych powodowało, że pojedyncze impulsy były naliczane w sposób nieprawidłowy. Ze względu na zastosowane rozwiązanie trzeba było przechowywać te wartości dla kolejnych wywołań bloków, dlatego rozwiązaniem okazało się przeniesienie tych zmiennych z~tymczasowych do~statycznych. 
\end{itemize}
\indent
\indent Wszystkie problemy zostały rozwiązane i~w~ostatecznej wersji oprogramowania nie wpływają one w~negatywny sposób na pracę modelu. Niestety dwa pierwsze problemy nie posiadają dobrego rozwiązania, więc należało statycznie analizować tworzone oprogramowanie celem uniknięcia błędów z~nich wynikających.
%\subsection{Perspektywy rozwoju}

\begin{comment}
\begin{itemize}
\item Rozbudowanie modelu o możliwość poruszania się na gąsienicach lub kołach, aby mógł obsługiwać większy magazyn.
\item Rozbudowanie o magazyn z czujnikami i platformą startową.
\item Zaprojektować rozwiązanie sterowania modelu bezprzewodowo.
\item Celem zbudowania czegoś praktycznego, można by model robota połączyć z jakąś taśmą produkcyjną, aby zasymulować działanie fabryki.
\end{itemize}
\end{comment}
